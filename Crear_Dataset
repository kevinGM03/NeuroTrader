import os
import pandas as pd

# Ruta del directorio raíz que contiene las carpetas por año
root_folder = r'/content/drive/My Drive/PROYECTO/DATOS HISTORICOS'

# Crear una lista para almacenar todos los DataFrames
all_data = []

# Recorrer las carpetas de cada año
for year_folder in os.listdir(root_folder):
    year_path = os.path.join(root_folder, year_folder)

    # Verificar si es una carpeta
    if os.path.isdir(year_path):
        # Recorrer los archivos dentro de la carpeta del año
        for file_name in os.listdir(year_path):
            if file_name.endswith('.csv'):
                file_path = os.path.join(year_path, file_name)

                # Leer el archivo CSV
                df = pd.read_csv(file_path)

                # Agregar los datos al conjunto
                all_data.append(df)

# Combinar todos los DataFrames en uno solo
if all_data:
    historical_data = pd.concat(all_data, ignore_index=True)

    # Asegúrate de que los datos estén ordenados por el tiempo
    historical_data.sort_values(by='timestamp', inplace=True)
    historical_data.reset_index(drop=True, inplace=True)

    # Funciones para calcular indicadores técnicos
    def calculate_indicators(df):
        # EMAs
        df['EMA_9'] = df['close'].ewm(span=9, adjust=False).mean()
        df['EMA_21'] = df['close'].ewm(span=21, adjust=False).mean()

        # MACD
        df['MACD'] = df['EMA_9'] - df['EMA_21']
        df['Signal_Line'] = df['MACD'].ewm(span=9, adjust=False).mean()

        # RSI de 14 periodos
        df['RSI'] = calculate_rsi(df['close'], 14)

        # OBV
        df['OBV'] = calculate_obv(df)

        # Bandas de Bollinger de 20 periodos
        df['Bollinger_Upper'], df['Bollinger_Lower'] = calculate_bollinger_bands(df['close'], window=20)

        return df

    def calculate_rsi(series, period=14):
        delta = series.diff()
        gain = (delta.where(delta > 0, 0)).rolling(window=period).mean()
        loss = (-delta.where(delta < 0, 0)).rolling(window=period).mean()
        rs = gain / loss
        return 100 - (100 / (1 + rs))

    def calculate_obv(df):
        obv = [0]
        for i in range(1, len(df)):
            if df['close'][i] > df['close'][i - 1]:
                obv.append(obv[-1] + df['volume'][i])
            elif df['close'][i] < df['close'][i - 1]:
                obv.append(obv[-1] - df['volume'][i])
            else:
                obv.append(obv[-1])
        return pd.Series(obv)

    def calculate_bollinger_bands(series, window=20):
        ma = series.rolling(window).mean()
        std = series.rolling(window).std()
        upper_band = ma + (std * 2)
        lower_band = ma - (std * 2)
        return upper_band, lower_band

    # Función para generar etiquetas basadas en la alineación de indicadores
    def generate_labels(df):
        df['Signal_Initial'] = 0  # Inicializar con "Mantener"
        df['Signal_Filtered'] = 0
        df['Signal_Final'] = 0

        # Señales iniciales de Compra
        df.loc[
            (df['EMA_9'] > df['EMA_21']) &  # EMA cruz alcista
            (df['MACD'] > df['Signal_Line']),  # MACD cruz alcista
            'Signal_Initial'
        ] = 1  # Comprar

        # Señales iniciales de Venta
        df.loc[
            (df['EMA_9'] < df['EMA_21']) &  # EMA cruz bajista
            (df['MACD'] < df['Signal_Line']),  # MACD cruz bajista
            'Signal_Initial'
        ] = -1  # Vender

        # Filtrar señales falsas (ejemplo usando RSI y OBV)
        df.loc[
            (df['Signal_Initial'] == 1) & (df['RSI'] < 70) & (df['OBV'] > 0),
            'Signal_Filtered'
        ] = 1
        df.loc[
            (df['Signal_Initial'] == -1) & (df['RSI'] > 30) & (df['OBV'] < 0),
            'Signal_Filtered'
        ] = -1

        # Generar señal final
        df['Signal_Final'] = df['Signal_Filtered']

        return df

    # Aplicar el cálculo de indicadores
    historical_data = calculate_indicators(historical_data)

    # Eliminar filas con valores faltantes
    historical_data.dropna(inplace=True)

    # Generar etiquetas
    historical_data = generate_labels(historical_data)

    # Guardar el DataFrame con indicadores y etiquetas en un nuevo archivo CSV
    output_file = r'/content/drive/My Drive/PROYECTO/DATASET/Dataset_with_indicators_and_labels.csv'
    os.makedirs(os.path.dirname(output_file), exist_ok=True)
    historical_data.to_csv(output_file, index=False)
    print(f"Archivo con indicadores técnicos y etiquetas guardado como '{output_file}'")
else:
    print("No se encontraron datos para procesar.")
